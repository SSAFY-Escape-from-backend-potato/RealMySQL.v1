## 1. 데이터베이스의 인덱스에 대해 설명해주세요.

- 인덱스는 데이터를 효율적으로 조회하기 위해 사용되는 자료구조입니다. MySQL의 경우 B+Tree를 기본으로 사용하여 주어진 키 순서로 정렬하여 저장합니다. CUD 성능을 희생하고 R의 성능을 극대화하는 목적으로 사용됩니다. 서비스의 특성을 고려하여 Read, Write 비율을 적절하게 따져서 인덱스를 설정하는 것이 중요합니다.

## 2. 인덱스에서 B+Tree 구조 대신 트리 구조나 Hash 구조를 사용하지 않는 이유는 무엇이라 생각하시나요?

- B+Tree가 인덱스 구조로 많이 사용되는 이유는 범위 검색과 특정 키 값으로 정렬됨에 있습니다. Hash는 자료구조 특성상 Range Scan이 불가능하기 때문에 기본 인덱스르 채택하기에는 어려움이 있습니다. 물론 자주 조회되는 값들에 대해서 어댑티브 해시 인덱스를 메모리에 만들어둠으로써 일부 조회 성능을 높일 수는 있습니다. 트리 구조는 Depth가 많이 깊어져 Disk I/O가 많이 발생할 수 있습니다.

## 3. 클러스터 인덱스와 세컨더리 인덱스의 차이는 무엇인가요?

- 클러스터 인덱스는 실제 데이터가 물리적 저장소에 순서대로 정렬되어 저장되는 인덱스입니다. PK에 대해 생성되며 이 인덱스의 리프 노드에는 실제 데이터 레코드가 저장되어 있습니다. 즉 인덱스 자체가 데이터를 포함하고 있어 별도의 추가 탐색 없이 원하는 데이터를 빠르게 조회할 수 있습니다. 특히 PK 기준의 Range Scan에 매우 효율적입니다. 반면 세컨더리 인덱스는 클러스터 인덱스와 달리 데이터의 물리적 정렬과는 무관합니다. B+Tree 구조로 인덱스 키 값만 정렬되어 있으며 리프 노드에는 해당 레코드의 PK가 저장됩니다. 실제 데이터를 조회하기 위해선 이 PK를 이용해 클러스터 인덱스를 한 번 더 타고 들어가는 과정을 거치므로 Disk Random I/O가 추가로 발생합니다.

## 4. 프로젝트를 진행하면서 인덱스를 설정해본 경험에 대해서 설명해주세요.

- 제품을 조회할 때 최근 인기있는 상품순으로 조회를 수행해야 하는 요구사항이 있었습니다. 저는 (최근 조회수, PK)를 Multi Column Index로 설정하여 No-Offset Pagination 처리를 하여 조회 성능을 개선하였습니다.

### 4.1 인덱스를 설정하신 테이블에 인덱스를 거는 것이 합당한지 아닌지에 대해 본인의 생각을 말씀해주세요.

- 보통의 경우 인덱스를 설정하면 Write 성능이 안좋아집니다. 제가 인덱스를 설정했던 상품 정보 테이블의 특성상 상품이 등록되는 빈도보다 조회하는 비율이 높다고 판단되었기 때문에 쓰기 성능에 대한 손해를 감안하더라도 조회 성능을 향상 시키는 것이 서비스 측면에서 이득이라고 판단했습니다.

### 4.2 읽기:쓰기 비가 어느정도 되어야 인덱스를 통해 성능상 이익을 볼 수 있을까요?

- 통상적으로 읽기 비율이 80%가 넘는 서비스에서 뚜렷한 성능상 이득을 볼 수 있습니다. 반면 70%이하로 읽기 비율이 떨어진다면, 꼭 필요한 핵심 컬럼에만 인덱싱을 수행하는 것이 좋습니다. 읽기 비율이 50% 미만으로 떨어진다면 인덱싱을 수행하는 것이 쓰기에 많은 부담을 주기 때문에 일반적으로 성능상 불이익을 초래합니다.

## 5. Auto Increment로 설정된 값을 PK로 쓰면 어떤 장점과 단점이 있나요? UUID로 지정했을 때와는 어떤 차이가 있을까요?

- Auto Increment의 경우 순차적으로 증가하는 값을 쓰기 때문에 순차적으로 물리 저장소에 저장되어 지역성을 활용하기 좋습니다. 하지만 분산 환경에서 동시에 Insert가 들어올 경우 충돌 가능성이 있고 ID가 유추 가능하기 때문에 보안상 이슈가 있을 수 있습니다. UUID의 경우 랜덤으로 생성되는 값이기 때문에 무작위로 저장되어 성능 저하가 발생할 수 있습니다. 정렬 가능한 UUID를 사용하면 위 문제도 해결됩니다.

## 추가 1. Having절과 Where 절의 차이는 무엇인가요?

- Where 절과 Having 절의 차이를 이해하기 위해선 쿼리의 실행 순서를 먼저 보아야 합니다. Where 절은 From과 Join절로 데이터를 가져온 뒤 집계가 일어나기 전 적용이 되고, Having 절은 집계가 일어난 이후에 적용이 됩니다. 따라서, Where 절에는 집계 값이 아닌 데이터에 대해서 적용이 가능하며 Having 절에서는 집계 기준이 되는 컬럼 혹은 집계 값에 대해서 적용하여 해당하는 값을 필터링할 수 있습니다. 만약 어느 절에 넣어도 되는 조건이라면 Where절에 걸어 놓는 것이 낫습니다. 그 이유는 데이터를 미리 더 줄여서 가져올 수 있기 때문에 조건 연산에 필요한 리소스를 줄일 수 있습니다.
